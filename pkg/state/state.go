// Package state provides domain state management for the domain checker application
package state

import (
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/mallocator/domain-checker/pkg/config"
	"github.com/mallocator/domain-checker/pkg/logger"
)

// DomainState holds per-domain flags and expiry
type DomainState struct {
	// Domain expiration date
	Expiration time.Time `json:"expiration"`

	// Whether we've already notified about expiry
	NotifiedExpiry bool `json:"notified_expiry"`

	// Whether we've already notified about availability
	NotifiedAvailable bool `json:"notified_available"`
}

// Manager handles domain state operations
type Manager struct {
	cfg *config.Config
	log *logger.Logger
}

// New creates a new state manager
func New(cfg *config.Config, log *logger.Logger) *Manager {
	return &Manager{
		cfg: cfg,
		log: log,
	}
}

// FilePath returns the JSON path for a domain
func (m *Manager) FilePath(domain string) string {
	safe := strings.ReplaceAll(domain, ".", "_")
	return filepath.Join(m.cfg.StateDir, safe+".json")
}

// Load reads state for a domain, logs errors
func (m *Manager) Load(domain string) DomainState {
	path := m.FilePath(domain)
	var st DomainState
	data, err := os.ReadFile(path)
	if err == nil {
		if err := json.Unmarshal(data, &st); err != nil {
			m.log.Warnf("Parse state error for %s: %v", domain, err)
		}
	}
	return st
}

// Save writes state file for a domain
func (m *Manager) Save(domain string, st DomainState) {
	data, err := json.MarshalIndent(st, "", "  ")
	if err != nil {
		m.log.Errorf("Marshal state error for %s: %v", domain, err)
		return
	}
	if err := os.WriteFile(m.FilePath(domain), data, 0644); err != nil {
		m.log.Warnf("Write state error for %s: %v", domain, err)
	}
}

// IsAppGeneratedFile checks if a file was generated by this application
// by attempting to parse it as a DomainState JSON
func (m *Manager) IsAppGeneratedFile(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}

	var state DomainState
	if err := json.Unmarshal(data, &state); err != nil {
		return false
	}

	// Additional validation could be added here if needed
	// For example, checking if specific fields have valid values

	return true
}

// Cleanup removes files not in current domain list
func (m *Manager) Cleanup() {
	files, err := os.ReadDir(m.cfg.StateDir)
	if err != nil {
		m.log.Warnf("Could not read state dir %s: %v", m.cfg.StateDir, err)
		return
	}
	
	keep := make(map[string]struct{}, len(m.cfg.Domains))
	for _, d := range m.cfg.Domains {
		keep[strings.ReplaceAll(strings.TrimSpace(d), ".", "_")] = struct{}{}
	}
	
	for _, f := range files {
		// Only process files with .json extension
		if !strings.HasSuffix(f.Name(), ".json") {
			continue
		}

		base := strings.TrimSuffix(f.Name(), ".json")
		if _, ok := keep[base]; !ok {
			path := filepath.Join(m.cfg.StateDir, f.Name())

			// Verify this is a file created by our app by checking if it's a valid DomainState JSON
			if m.IsAppGeneratedFile(path) {
				if err := os.Remove(path); err != nil {
					m.log.Warnf("Failed to remove stale %s: %v", path, err)
				} else {
					m.log.Infof("Removed stale state %s", path)
				}
			} else {
				m.log.Debugf("Skipping non-app file: %s", path)
			}
		}
	}
}